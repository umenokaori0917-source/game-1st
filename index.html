<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>薄明のResonance - Web乙女ノベル ‐ </title>
<style>
  :root{
    --bg:#0f1116;--panel:#171a22;--ink:#e8ecf1;--sub:#a6b0be;--accent:#7aa2f7;--warn:#f7768e
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.7 system-ui,-apple-system,"Segoe UI",Roboto}
  #app{max-width:880px;margin:0 auto;padding:16px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
  header h1{font-size:18px;margin:0;color:var(--ink)}
  header .mini{color:var(--sub);font-size:12px}
  #stage{background:var(--panel);border:1px solid #22252e;border-radius:12px;min-height:320px;padding:18px;margin-top:12px;position:relative}
  .name{font-weight:700;color:var(--accent);margin-bottom:6px}
  .text{white-space:pre-wrap}
  #choices{margin-top:16px;display:grid;gap:10px}
  button.choice{background:#22283a;color:var(--ink);border:none;padding:12px;border-radius:10px;text-align:left}
  button.choice[disabled]{opacity:.55}
  #ui{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
  #ui button,#ui .seg{background:#263146;border:1px solid #2f3950;color:var(--ink);padding:8px 10px;border-radius:8px}
  #ui .seg{display:flex;align-items:center;gap:8px}
  #ui input[type="range"]{width:140px}
  #log{margin-top:12px;color:var(--sub);background:#12141a;border-radius:10px;padding:10px;max-height:160px;overflow:auto;font-size:13px}
  #badges{margin-top:8px;font-size:12px;color:var(--sub)}
  .pill{display:inline-block;border:1px solid #2f3950;border-radius:999px;padding:2px 8px;margin:2px}
  a{color:var(--accent);text-decoration:none}
  .sep{opacity:.5;margin:0 6px}
  .mark-read{position:absolute;right:12px;top:10px;font-size:12px;color:var(--sub);opacity:.8}
  .unread{color:var(--warn);font-weight:700}
  .toggle-on{outline:2px solid var(--accent)}
  /* === 軌跡ポップアップ === */
  #journalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;z-index:50}
  #journalModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
    width:min(880px,92vw);max-height:80vh;overflow:auto;display:none;z-index:51;
    background:var(--panel);border:1px solid #2f3950;border-radius:12px;padding:16px}
  #journalModal h2{margin:0 0 8px 0;font-size:18px;color:var(--ink)}
  #journalModal .grid{display:grid;grid-template-columns:1fr;gap:12px}
  #journalModal section{background:#12141a;border:1px solid #2f3950;border-radius:10px;padding:12px}
  #journalModal .row{display:flex;justify-content:space-between;gap:8px}
  #journalModal .close{position:sticky;top:0;margin-left:auto;background:#263146;border:1px solid #2f3950;
    color:var(--ink);padding:6px 10px;border-radius:8px}
  #journalModal ul{margin:6px 0 0 16px}
  #journalModal table{width:100%;border-collapse:collapse;font-size:14px}
  #journalModal td{border-top:1px solid #2f3950;padding:6px 4px}
  #journalModal td:first-child{color:var(--sub)}
  /* 画面には出さない要素を非表示化 */
  #badges{display:none}
  #log{display:none}
  /* === 背景＆立ち絵レイヤ === */
  #stage{position:relative}
  /* クリックで進める状態の見た目 */
  #stage.advance { cursor: pointer; }
  #bgLayer{position:absolute;inset:0;background:#000 center/cover no-repeat;opacity:.95;z-index:0;transition:opacity .45s ease, filter .45s ease}
  #spriteLayer{position:absolute;inset:0;pointer-events:none;z-index:1}
  .sprite{position:absolute;bottom:0;transform:translateX(-50%);background-size:contain;background-repeat:no-repeat;width:38%;height:90%;opacity:1;transition:opacity .3s ease, transform .3s ease}
  .sprite.left{left:22%}
  .sprite.center{left:50%}
  .sprite.right{left:78%}
  /* テキスト層を最前面に */
  #stage .name,#stage .text,#stage #choices,#stage .mark-read{position:relative;z-index:2}
</style>
</head>
<body>
<div id="journalBackdrop"></div>
<div id="journalModal" role="dialog" aria-modal="true" aria-label="軌跡">
  <div class="row" style="margin-bottom:8px">
    <h2>軌跡</h2>
    <button class="close" id="btnJournalClose">閉じる ✕</button>
  </div>
  <div class="grid">
    <section>
      <div class="row"><strong>隠しキャラ</strong><span id="jrHidden"></span></div>
      <div class="row"><strong>ED達成状況</strong><span id="jrEDCount"></span></div>
    </section>
    <section>
      <strong>ED一覧</strong>
      <ul id="jrEDList" style="margin-top:6px"></ul>
    </section>
    <section>
      <strong>入手した「記憶の欠片」</strong>
      <ul id="jrFragments"></ul>
    </section>
    <section>
      <strong>キャラ別好感度</strong>
      <table id="jrAffection"></table>
    </section>
    <section>
      <strong>ログ</strong>
      <ul id="jrLogs" style="max-height:260px;overflow:auto;margin-top:6px"></ul>
    </section>
  </div>
</div>
<div id="app">
  <audio id="bgm" loop preload="none"></audio>
  <audio id="se" preload="auto"></audio>
  <header>
    <h1>薄明のResonance<span class="mini"> - Web乙女ノベル ‐ </span></h1>
    <div class="mini">v1.1</div>
  </header>

  <div id="stage">
    <div id="bgLayer"></div>
    <div id="spriteLayer"></div>
    <div class="mark-read" id="readmark"></div>
    <div class="name" id="speaker"></div>
    <div class="text" id="text"></div>
    <div id="choices"></div>
  </div>

  <div id="ui">
    <button id="btnBack">◀︎ 戻る</button>
    <button id="btnSkipRead">⏭ 既読スキップ</button>
    <div class="seg">
      <button id="btnToggleSkip">既読SKIP: OFF</button>
      <span class="mini">（既読＆単一選択は自動進行）</span>
    </div>
    <div class="seg">
      <button id="btnAutoplay">自動送り: OFF</button>
      <label class="mini">速度 <input id="speed" type="range" min="800" max="4000" step="100" value="1800"></label>
      <span id="speedVal" class="mini">1.8s</span>
    </div>
    <span class="sep">|</span>
    <button id="btnSave">セーブ</button>
    <button id="btnLoad">ロード</button>
    <button id="btnReset">初期化</button>
    <button id="btnJournal">軌跡</button>
  </div>

  <div id="badges"></div>
  <div id="log" aria-label="backlog"></div>
</div>

<script>
  // 互換: structuredClone が無い環境向け
const deepClone = (obj)=> (window.structuredClone ? structuredClone(obj)
                                                : JSON.parse(JSON.stringify(obj)));
/* =========================================================
   シナリオ定義（効果非表示）
   ========================================================= */
const SCENES = (window.SCENES = window.SCENES || {});
// ───────── タイトル／共通 ─────────
SCENES["title"] = {
    name:"薄明のResonance",
    bg:"title_dark",
    music:"calm_day",
    text:"現代ファンタジー×選択式ノベル。\n共通ルートを進め、各キャラのルートを解放しよう。\n恋愛EDを集め、記憶の欠片を集めると——『静寂の声』が現れる。",
    choices: [
      { label:"▶︎ 共通ルートから始める", next:"start" },
      { label:"▶︎ 静寂の声", next:"H1", req: isHiddenUnlocked }
    ]
  },

SCENES["start"] = {
    name: "澪",
    text: "…また同じ夢。見知らぬ誰かの声が、水底から届くように胸を震わせる。\n目覚めると、手のひらに残る温度だけが現実で、言葉は残らない。\n今日は放課後、図書館で十年前の事件を調べようと思う。何かが、そこに繋がっている気がする。",
    choices: [
     { label: "図書館へ向かう", next: "lib1" }
    ],
    onEnter: (s)=>logPush("【プロローグ】")
  },

SCENES["lib1"] = {
    name: "澪",
    text: "静かな紙の匂い。\n古い綴じ込みの片隅に、『神ノ原 記憶消失事件』の見出しが黄ばんで眠っていた。\n頁をめくる手が震える。読み進めるほど、私の中の“既視感”は輪郭を得ていく。",
    choices: [
      { label: "さらに読み進める", next: "lib_gain", addFragment:"欠片01_古新聞" }
    ]
  },

SCENES["lib_gain"] = {
    name:"",
    text:"【記憶の欠片】\n欠片①『古新聞：失われた学級記録』を手に入れた。",
    choices:[{label:"外の空気を吸いに行く", next:"roof"}]
  },

SCENES["roof"] = {
    name: "澪",
    text: "外の空気を吸いに屋上へ出た。\nふと屋上で風に舞っていたメモを追い、手すり越しに指先で掴む。\n『実験計画＿被験者M-0』という活字が、紙に浅く残っていた。",
    choices: [{ label: "メモをしまう", next: "roof_gain", addFragment: "欠片02_屋上のメモ" }]
  },

SCENES["roof_gain"] = {
    name:"",
    text:"【記憶の欠片】\n欠片②『屋上のメモ：実験計画＿被験者M-0』を手に入れた。",
    choices:[{label:"廃部室へ向かう", next:"forkPrep"}]
  },

SCENES["forkPrep"] = {
    name: "",
    text: "用事を思い出し、廃部室へ向かう。\n部室に置いてある古びた写真立てに触れると、遠い笑い声が一瞬流れ込む。",
    choices: [{ label: "すぐにその場を離れる", next: "forkPrep_gain", addFragment: "欠片03_写真立て" }]
  },

SCENES["forkPrep_gain"] = {
    name:"",
    text:"【記憶の欠片】\n欠片③『写真立て：いつかの記憶』を手に入れた。",
    choices:[{label:"外の空気を吸いに行く", next:"firstMeetHub"}]
  },

SCENES["firstMeetHub"] = {
    name: "",
    text: "今日はなんだか疲れた。",
    choices: [
      { label: "帰路につく", next: "branch", setAffection: {"九条": +1}, setFlags:{wentLibrary:true} },
      { label: "友人に会いに行く", next:"branch", setAffection: {"朝倉": +1, "湊": +1}, setFlags:{wentCafe:true} },
      { label: "別のことを考える", next:"branch", setAffection: {"藤堂": +1}, setFlags:{repliedMail:true} },
    ]
  },

SCENES["branch"] = {
    name: "",
    text: "誰の隣で、この揺らぐ世界を歩く？（個別ルート開始）",
    choices: [
      { label: "朝倉 晃のもとへ向かう", next: "A1", req:(s)=> (s.affection["朝倉"]||0) >= 1 || s.flags.wentCafe },
      { label: "九条 煌に会いに行く", next: "K1", req:(s)=> (s.affection["九条"]||0) >= 1 || s.flags.wentLibrary },
      { label: "神原 湊を探す", next: "M1", req:(s)=> (s.affection["湊"]||0) >= 1 || s.flags.wentCafe },
      { label: "藤堂 理久の研究室へ", next: "R1", req:(s)=> (s.affection["藤堂"]||0) >= 1 || s.flags.repliedMail || s.flags.agreedResearch },
      { label: "篠宮 奏と過ごす（友情）", next: "N1", req:(s)=> true }
    ]
  };
  
  SCENES[src="routes/Kujou.js"]
  SCENES[src="routes/Asakura.js"]
  SCENES[src="routes/Minato.js"]
  SCENES[src="routes/Todo.js"]
  SCENES[src="routes/Kanade.js"]
  SCENES[src="routes/Hidden.js"]
  
  /* ───────── 隠し：東雲 悠真 ルート（詳細＋演出） ───────── */
  SCENES["H1"] = {
    name:"",
    bg:"dream_void", music:"melancholy", sprite:[
      {char:"mio", pose:"think", pos:"center"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    se:"chime",
    text:"白い無音に、足音だけが生まれては消える。「やっと来たね」男は微笑む。光の粒が肩口でほどけ、輪郭に戻る。「ここは記憶の“外側”。君が選んだどの結末も否定しない、静かな場所」(夢の声と同じ温度——東雲 悠真)",
    choices:[
      {label:"「あなたは誰？」", next:"H1_who"},
      {label:"「どうして、ずっと呼んでたの」", next:"H1_voice"},
      {label:"「ここで、何ができるの」", next:"H2"}
    ]
  };
  
  SCENES["H1_who"] = {
    name:"",
    bg:"dream_void", music:"melancholy", sprite:[
      {char:"mio", pose:"speak", pos:"center"},
      {char:"yuma", pose:"serious", pos:"right"}
    ],
    text:"「東雲 悠真。——“守護者”だと自称してる」自嘲の笑み。「十年前、世界は一度だけ綺麗な嘘で縫われた。君は被験者M-0、私は調整役。縫い目がほどけるたび、君を呼んで繕ってきた」",
    choices:[{label:"「次へ」", next:"H2"}]
  };
  
  SCENES["H1_voice"] = {
    name:"",
    bg:"dream_void", music:"tender", sprite:[
      {char:"mio", pose:"think", pos:"center"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「『誰かの代わりに生きろ』は、命令じゃない。救命の合図だった」彼は手を胸に当てる。「君が沈むたび、浮かぶ言葉を探した。間違っていたら、ごめん」(謝る声がいちばん、現実に近い)",
    choices:[{label:"「続けて」", next:"H2"}]
  };
  
  SCENES["H2"] = {
    name:"",
    bg:"memory_gallery", music:"truth", sprite:[
      {char:"mio", pose:"think", pos:"left"},
      {char:"yuma", pose:"serious", pos:"right"}
    ],
    text:"回廊に額装が並ぶ。写真、ログ、鍵、契約書——私が集めた欠片が、壁で静かに呼吸する。「ここでは、選び直せる。修復か、受容か。その前に——見たいものを見て」",
    choices:[
      {label:"学級写真の“右下”を見る", next:"H3_photo"},
      {label:"旧プール側棟の廊下を再現する", next:"H3_pool"},
      {label:"『縫合プロトコルv0.9』の原本を見る", next:"H3_protocol"},
      {label:"十分に見た。アンカーを選ぶ", next:"H4_anchor"}
    ]
  };
  
  SCENES["H3_photo"] = {
    name:"",
    bg:"classroom_past", music:"melancholy", sprite:[
      {char:"mio", pose:"shock", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    se:"paper",
    text:"集合写真の右下——切り取られていた位置に、薄い像が重なる。笑い皺、少し曲がった名札。『SHINONOME』(やっぱり、ここに——) 「僕だよ」悠真は淡く笑った。「君の隣にいた」",
    choices:[
      {label:"「どうして消えたの」", next:"H3_photo_why"},
      {label:"回廊に戻る", next:"H2"}
    ]
  };
  SCENES["H3_photo_why"] = {
    name:"",
    bg:"classroom_past", music:"melancholy", sprite:[
      {char:"mio", pose:"speak", pos:"left"},
      {char:"yuma", pose:"pained", pos:"right"}
    ],
    text:"「事故の日、僕は代わりに“責任者”になった。君の記録を守るために、僕の位置を切り離す。それがプロトコルだった」(右下の空白は、盾だった)",
    choices:[{label:"回廊に戻る", next:"H2"}]
  };
  
  SCENES["H3_pool"] = {
    name:"",
    bg:"pool_corridor_dark", music:"suspense", sprite:[
      {char:"mio", pose:"think", pos:"left"},
      {char:"yuma", pose:"serious", pos:"right"}
    ],
    se:"pulse",
    text:"濡れた廊下、等間隔の雫。錆びた鍵が掌で冷える。「ここで世界は縫われた。笑い声は、君を落ち着かせるための音響データ」(優しさの形が、時々刃になる)",
    choices:[
      {label:"「鍵は、何の扉」", next:"H3_pool_key"},
      {label:"回廊に戻る", next:"H2"}
    ]
  };
  SCENES["H3_pool_key"] = {
    name:"",
    bg:"pool_corridor_dark", music:"truth", sprite:[
      {char:"mio", pose:"speak", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「最初の縫合室。もう開けない。——開けなくていい」彼は静かに言う。(それでも、持っていたい。選ぶために)",
    choices:[{label:"回廊に戻る", next:"H2"}]
  };
  
  SCENES["H3_protocol"] = {
    name:"",
    bg:"lab_white", music:"truth", sprite:[
      {char:"mio", pose:"think", pos:"left"},
      {char:"yuma", pose:"serious", pos:"right"}
    ],
    text:"『縫合プロトコル v0.9』。黒塗りの署名の下に、消し残った走り書きがある。——“守るのは現在”。「君の現在を守るための嘘。それがこの世界の骨組み」",
    choices:[
      {label:"「じゃあ、今を壊さず直せる？」", next:"H3_protocol_fix"},
      {label:"回廊に戻る", next:"H2"}
    ]
  };
  SCENES["H3_protocol_fix"] = {
    name:"",
    bg:"lab_white", music:"tender", sprite:[
      {char:"mio", pose:"speak", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「可能かもしれない。痛みは出る。けど、前よりは優しくできる」(“優しく”直す。そんな選択肢があるなら——)",
    choices:[{label:"回廊に戻る", next:"H2"}]
  };
  
  /* 4章：アンカー選択（各ルートで得た現在を参照） */
  SCENES["H4_anchor"] = {
    name:"",
    bg:"memory_gallery", music:"calm_day", sprite:[
      {char:"mio", pose:"think", pos:"left"},
      {char:"yuma", pose:"serious", pos:"right"}
    ],
    text:"「修復にも受容にも、“現在”を固定する錘が要る」悠真は手を差し出す。「君が選んできた誰かの現在——その在り方を、言葉にして」",
    choices:[
      {label:"九条：距離が守る優しさ", next:"H4_k", req:(s)=>!!s.flags.ED_Kujou_Love},
      {label:"朝倉：守るための嘘", next:"H4_a", req:(s)=>!!s.flags.ED_Asakura_Love},
      {label:"湊：小さな生活の誇り", next:"H4_m", req:(s)=>!!s.flags.ED_Minato_Love},
      {label:"藤堂：同じ速度で歩く", next:"H4_r", req:(s)=>!!s.flags.ED_Todo_Love},
      {label:"アンカーは決めた。最終選択へ", next:"H5_choice"}
    ]
  };
  
  SCENES["H4_k"] = {
    name:"",
    bg:"public_hall_dim", music:"tender", sprite:[
      {char:"mio", pose:"smile", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「触れない距離が、守るための形になる」言葉にすると胸が軽くなる。「うん。距離は欠落じゃない。設計だ」",
    choices:[{label:"回廊へ戻る", next:"H4_anchor"}]
  };
  SCENES["H4_a"] = {
    name:"",
    bg:"cafe_night", music:"warmth", sprite:[
      {char:"mio", pose:"smile", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「嘘は盾。合言葉で意味を共有する」悠真は頷く。「共有された嘘は、もう孤独じゃない」",
    choices:[{label:"回廊へ戻る", next:"H4_anchor"}]
  };
  SCENES["H4_m"] = {
    name:"",
    bg:"shop_morning", music:"warmth", sprite:[
      {char:"mio", pose:"smile", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「働いて、笑って、眠る。小さいけど、確かな誇り」「世界の大工事より、生活のネジを締める方が難しいんだ」",
    choices:[{label:"回廊へ戻る", next:"H4_anchor"}]
  };
  SCENES["H4_r"] = {
    name:"",
    bg:"lab_evening", music:"tender", sprite:[
      {char:"mio", pose:"smile", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"「ブレーキを持ち合うと、同じ速度で歩ける」悠真は小さく笑う。「じゃあ、急がない処置を選べるね」",
    choices:[{label:"回廊へ戻る", next:"H4_anchor"}]
  };
  
  /* 5章：最終選択（修復 or 受容） */
  SCENES["H5_choice"] = {
    name:"",
    bg:"dream_void", music:"truth", sprite:[
      {char:"mio", pose:"think", pos:"center"},
      {char:"yuma", pose:"serious", pos:"right"}
    ],
    se:"pulse",
    text:"「選んで。世界を修復するか、現実を受け入れるか」白い空間に、二つの扉が静かに立つ。(どちらを選んでも、私の現在は私が決める)",
    choices:[
      {label:"世界を修復する（トゥルー）", next:"H6a", setFlags:{ED_Hidden_True:true}},
      {label:"現実を受け入れる（ビターグッド）", next:"H6b", setFlags:{ED_Hidden_Bitter:true}}
    ]
  };
  
  /* 6章：ED */
  SCENES["H6a"] = {
    name:"",
    bg:"rooftop_dawn", music:"warmth", sprite:[
      {char:"mio", pose:"smile", pos:"left"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    se:"breath",
    text:"【トゥルーED：縫合の完了】欠片は矛盾なく繋がり、右下の“空白”は空白のまま“役割”を得た。誰も上書きされず、物語は収束する。「正しい眠り方を、やっと覚えたね」「うん」朝の風は、やさしい重さで私たちを押した。",
    choices:[{label:"タイトルへ", next:"title"}]
  };
  
  SCENES["H6b"] = {
    name:"",
    bg:"starfield", music:"melancholy", sprite:[
      {char:"mio", pose:"think", pos:"center"},
      {char:"yuma", pose:"soft", pos:"right"}
    ],
    text:"【ビターグッド】継ぎ目はそのまま、しかし手当ては施された。ほつれを知っている者だけが見つけられる、静かな幸福。「君が見つけた現在を、僕は見失わない」「私も」遠くで、昨日と同じ雨が降りはじめる。",
    choices:[{label:"タイトルへ", next:"title"}]
  };
  
  // ───────── ED記録・メニュー復帰 ─────────
  SCENES["ED_Collector"] = {
    name:"",
    text:"【ED記録を更新】必要条件を満たすと、タイトルに『静寂の声』が出現します。",
    choices:[{label:"タイトルへ戻る", next:"title"}]
  }; 

// 隠し解放条件：朝倉/九条/湊/藤堂の恋愛ED ＋ 欠片3つ以上
function isHiddenUnlocked(s){
  const needED = s.flags.ED_Asakura_Love && s.flags.ED_Kujou_Love
              && s.flags.ED_Minato_Love && s.flags.ED_Todo_Love;
  const enoughFragments = (s.fragments||[]).length >= 3;
  return needED && enoughFragments;
}

// どのシーンIDがどのファイルにいるかのざっくりマップ（先頭1文字で十分）
const ROUTE_LOADERS = {
  "K": "routes/kujou.js",
  "A": "routes/asakura.js",
  "M": "routes/minato.js",
  "R": "routes/todo.js",
  "N": "routes/kanade.js",
  "H": "routes/hidden.js",
};
const _loadedRouteFiles = new Set();

function ensureSceneLoaded(sceneId){
  if (SCENES[sceneId]) return Promise.resolve(true);
  const key = String(sceneId).charAt(0);
  const src = ROUTE_LOADERS[key];
  if (!src) return Promise.resolve(false); // マップに無ければ諦める

  if (_loadedRouteFiles.has(src)) {
    // 既に読んだのに無い → シーン名のタイプミスの可能性
    return Promise.resolve(!!SCENES[sceneId]);
  }

  return new Promise((resolve) => {
    const s = document.createElement("script");
    s.src = src;
    s.defer = true;
    s.onload = () => { _loadedRouteFiles.add(src); resolve(!!SCENES[sceneId]); };
    s.onerror = () => { console.warn("failed to load route file:", src); resolve(false); };
    document.head.appendChild(s);
  });
}

// REPLACE: DEFAULT_STATE をこの内容に差し替え
const DEFAULT_STATE = {
  sceneId: "title",
  flags: { skipReadToggle:false, autoplay:false, autoplayMs:1800 },
  affection: {},
  fragments: [],
  history: [],
  seen: {},     // 既読管理
  logs: []      // ★ 追加：ログ蓄積（画面には出さない）
};

let state = loadState() || deepClone(DEFAULT_STATE);
const elSpeaker = document.getElementById("speaker");
const elText = document.getElementById("text");
const elChoices = document.getElementById("choices");
const elLog = document.getElementById("log");
const elBadges = document.getElementById("badges");
const elReadmark = document.getElementById("readmark");
const btnBack = document.getElementById("btnBack");
const btnSkipRead = document.getElementById("btnSkipRead");
const btnToggleSkip = document.getElementById("btnToggleSkip");
const btnAutoplay = document.getElementById("btnAutoplay");
const rngSpeed = document.getElementById("speed");
const speedVal = document.getElementById("speedVal");
// ADD: 軌跡ポップアップ要素
const btnJournal = document.getElementById("btnJournal");
const journalModal = document.getElementById("journalModal");
const journalBackdrop = document.getElementById("journalBackdrop");
const btnJournalClose = document.getElementById("btnJournalClose");
// === 演出レイヤ参照 ===
const bgLayer = document.getElementById("bgLayer");
const spriteLayer = document.getElementById("spriteLayer");
const bgmEl = document.getElementById("bgm");
const seEl = document.getElementById("se");
let currentBg = "", currentBgm = "";

btnJournal && (btnJournal.onclick = openJournal);
btnJournalClose && (btnJournalClose.onclick = closeJournal);
journalBackdrop && (journalBackdrop.onclick = closeJournal);
document.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeJournal(); });
document.getElementById("btnSave").onclick = ()=>{ saveState(); alert("セーブしました"); };
document.getElementById("btnLoad").onclick = ()=>{ const ok=confirm("ロードしますか？未保存の進行は失われます。"); if(ok){ const s=loadState(); if(s){ state=s; render(); }}};
document.getElementById("btnReset").onclick = ()=>{ const ok=confirm("初期化しますか？"); if(ok){ state=deepClone(DEFAULT_STATE); saveState(); render(); }};
btnBack.onclick = back;
btnSkipRead.onclick = skipToNextUnread;
btnToggleSkip.onclick = ()=>{ state.flags.skipReadToggle = !state.flags.skipReadToggle; renderToggles(); render(); saveState(); };
btnAutoplay.onclick = toggleAutoplay;
rngSpeed.oninput = ()=>{ state.flags.autoplayMs = Number(rngSpeed.value); speedVal.textContent = (state.flags.autoplayMs/1000).toFixed(1)+"s"; saveState(); if(state.flags.autoplay){ restartAutoplay(); }};

let autoplayTimer=null;
// === 画像フォールバック（webp/png/jpg/jpegを順に試す） ===
async function resolveImageWithFallback(basePathNoExt, exts=["webp","png","jpg","jpeg"]) {
  for (const ext of exts) {
    const url = `${basePathNoExt}.${ext}`;
    try {
      await new Promise((res, rej)=>{
        const img = new Image();
        img.onload = ()=>res();
        img.onerror = ()=>rej();
        img.src = url;
      });
      return url; // 読めた拡張子が見つかった
    } catch(_) {}
  }
  return null; // どれも無かった
}

render();
function applyVisual(sc){
  if(sc.bg) setBg(sc.bg);
  if(sc.music) setBgm(sc.music);
  if(sc.sprite) setSprites(sc.sprite);
  if(sc.se) playSE(sc.se);
}

async function setBg(id){
  if(id===currentBg) return;
  currentBg = id;

  // assets/bg/<id>.(webp|png|jpg|jpeg) を順に試す
  const url = await resolveImageWithFallback(`assets/bg/${id}`);

  bgLayer.style.opacity = .6;

  if (url) {
    bgLayer.style.backgroundImage = `url(${url})`;
    bgLayer.style.backgroundSize = "cover";
    bgLayer.style.backgroundPosition = "center";
  } else {
    // 画像がまだ無い間のダミー背景（後で実ファイルを置けば自動で切替）
    bgLayer.style.backgroundImage =
      "linear-gradient(135deg, #0b0e14 0%, #1a2235 60%, #101521 100%)";
    bgLayer.style.backgroundSize = "cover";
    bgLayer.style.backgroundPosition = "center";
  }

  requestAnimationFrame(()=>{ bgLayer.style.opacity = .95; });
}

async function setSprites(list){
  spriteLayer.innerHTML = "";
  for (const sp of (list||[])) {
    const el = document.createElement("div");
    el.className = `sprite ${sp.pos||"center"}`;

    const base = `assets/sprites/${sp.char}_${sp.pose}`;
    const url = await resolveImageWithFallback(base, ["webp","png","jpg","jpeg"]);

    if (url) {
      el.style.backgroundImage = `url(${url})`;
      el.style.backgroundSize = "contain";
      el.style.backgroundRepeat = "no-repeat";
      el.style.backgroundPosition = "center bottom";
      el.style.opacity = "1";
    } else {
      // 画像が無い間は非表示（後でファイルを置けば自動表示）
      el.style.opacity = "0";
    }
    spriteLayer.appendChild(el);
  }
}

// ===== サウンド設定 =====
const SFX_ENABLED = false;         // ← SEを全部オフ（404を出さない）
const CHOICE_SE   = null;          // ← 選択音もオフ

// === BGM（mp3を優先、失敗したら無音で進む） ===
function setBgm(id){
  if(id === currentBgm) return;
  currentBgm = id;
  try{
    bgmEl.src = `assets/bgm/${id}.mp3`;
    bgmEl.volume = 0.8;
    bgmEl.play().catch(()=>{});    // ユーザー操作前ブロックは握りつぶす
  }catch(_){}
}

// === SE（404防止） ===
function playSE(id){
  if(!SFX_ENABLED) return;         // ← ここで一括ガード
  if(!id) return;
  try{
    seEl.src = `assets/se/${id}.mp3`;
    seEl.currentTime = 0;
    seEl.volume = 0.9;
    seEl.play().catch(()=>{});
  }catch(_){}
}

/* ---------- どこでも進む（テキスト/背景クリック → 次へ） ---------- */
// 「次に進める対象」を返す（単一選択 or scene.next）
function getAdvanceChoice(sc){
  // 1) 有効な選択肢が1つだけ
  const valid = getValidChoices(sc);
  if (valid.length === 1) return valid[0];

  // 2) 選択肢が無い & シーンに next 指定がある（オートなし運用用）
  if ((!sc.choices || sc.choices.length === 0) && sc.next) {
    return { label: "", next: sc.next }; // 疑似選択肢として扱う
  }
  return null; // 進めない（分岐 or 要手動）
}

// ステージクリックで前進（選択肢クリックは除外）
function onStageClick(e){
  // クリックが選択肢ボタン上なら無視
  if (e.target.closest("#choices")) return;
  // モーダル開いてる時も無視
  if (journalModal && journalModal.style.display === "block") return;

  const sc = SCENES[state.sceneId];
  const adv = getAdvanceChoice(sc);
  if (adv) choose(adv);
}

// キー操作（Enter / Space）で前進
function onKeyAdvance(e){
  // 入力欄操作やモーダル中は無視
  if (["INPUT","TEXTAREA","SELECT","BUTTON"].includes((e.target.tagName||"").toUpperCase())) return;
  if (journalModal && journalModal.style.display === "block") return;

  if (e.key === "Enter" || e.key === " ") {
    const sc = SCENES[state.sceneId];
    const adv = getAdvanceChoice(sc);
    if (adv) {
      e.preventDefault();
      choose(adv);
    }
  }
}

// 一度だけイベントを張る
(function setupAdvanceHandlers(){
  const stage = document.getElementById("stage");
  if (stage) stage.addEventListener("click", onStageClick);
  document.addEventListener("keydown", onKeyAdvance);
})();
  
/* ---------- レンダリング ---------- */
function render(){
  const sc = SCENES[state.sceneId];
  if(!sc){ return showText("","シーンが見つかりません: "+state.sceneId, []); }

  // onEnter: 一度だけ
  if(!state.flags["_entered_"+state.sceneId] && typeof sc.onEnter==="function"){
    sc.onEnter(state);
    state.flags["_entered_"+state.sceneId] = true;
  }

  // 既読マーキング
  const wasSeen = !!state.seen[state.sceneId];

  // 表示
  showText(sc.name||"", sc.text||"", buildChoices(sc));
  applyVisual(sc);

  // --- 追加：選択肢が無い＆autoNext指定なら自動遷移 ---
  if ((!sc.choices || sc.choices.length === 0) && sc.autoNext) {
    const delay = typeof sc.autoDelay === "number" ? sc.autoDelay : 0;
    setTimeout(()=>{
      state.history.push(state.sceneId);
      state.sceneId = sc.autoNext;
      render();
    }, delay);
  }
    
  // 既読表示
  elReadmark.innerHTML = wasSeen ? "既読" : '<span class="unread">未読</span>';

  // 既読スキップ：ONかつ既読かつ選択肢が1つ以下なら自動で進む
  if(state.flags.skipReadToggle && wasSeen){
    const validChoices = getValidChoices(sc);
    if(validChoices.length === 1){
      setTimeout(()=>choose(validChoices[0]), 0);
      return;
    }
  }

  // 既読登録
  state.seen[state.sceneId] = true;

  // バッジ更新
  updateBadges();
  renderToggles();

  function render(){
  const sc = SCENES[state.sceneId];
  if(!sc){ return showText("","シーンが見つかりません: "+state.sceneId, []); }

  // onEnter 一回だけ
  if(!state.flags["_entered_"+state.sceneId] && typeof sc.onEnter==="function"){
    sc.onEnter(state);
    state.flags["_entered_"+state.sceneId] = true;
  }

  // 表示
  showText(sc.name||"", sc.text||"", buildChoices(sc));
  applyVisual(sc);

  // ★ “クリックで進める”状態の見た目（カーソル）
  const stage = document.getElementById("stage");
  if (stage) {
    const adv = getAdvanceChoice(sc);
    stage.classList.toggle("advance", !!adv);
  }

  // 既読マークなど既存処理…
  const wasSeen = !!state.seen[state.sceneId];
  elReadmark.innerHTML = wasSeen ? "既読" : '<span class="unread">未読</span>';
  state.seen[state.sceneId] = true;

  updateBadges();
  renderToggles();

  // 自動送り（ON時は単一選択のみ）既存ロジック…
  if(state.flags.autoplay){ scheduleAutoplayStep(); }

  saveState();
}

  // 自動送り：ON時は単一選択のみ自動、複数選択は停止
  if(state.flags.autoplay){
    scheduleAutoplayStep();
  }

  saveState();
}

function showText(name, text, choiceElems){
  elSpeaker.textContent = name||"";
  elText.textContent = text||"";
  elChoices.innerHTML = "";
  choiceElems.forEach(cfg=>{
    const btn = document.createElement("button");
    btn.className = "choice";
    btn.textContent = cfg.label;
    if(cfg.disabled){ btn.disabled = true; }
    btn.onclick = ()=>choose(cfg);
    elChoices.appendChild(btn);
  });
}

/* ---------- 選択肢関連 ---------- */
function buildChoices(sc){
  const out=[];
  for(const ch of (sc.choices||[])){
    let ok = true;
    if(ch.req){ try{ ok = !!ch.req(state);}catch(e){ok=false;} }
    out.push({...ch, disabled: !ok});
  }
  return out;
}
function getValidChoices(sc){
  return (sc.choices||[]).filter(ch=>!ch.req || ch.req(state));
}

async function choose(ch){
  playSE(CHOICE_SE);
  if(ch.setFlags){ Object.assign(state.flags, ch.setFlags); }
  if(ch.setAffection){
    for(const k in ch.setAffection){
      state.affection[k] = (state.affection[k]||0) + ch.setAffection[k];
    }
  }
  if(ch.addFragment){
    if(!state.fragments.includes(ch.addFragment)){
      state.fragments.push(ch.addFragment);
      logPush("【欠片入手】"+ch.addFragment);
    }
  }

  // ★ ここがポイント：次のシーンが未定義なら対応ファイルを読み込む
  const ok = await ensureSceneLoaded(ch.next);
  if(!ok && !SCENES[ch.next]){
    alert("このルートの読み込みに失敗しました: " + ch.next);
    return;
  }

  state.history.push(state.sceneId);
  state.sceneId = ch.next;
  render();
}

function back(){
  const prev = state.history.pop();
  if(prev){ state.sceneId = prev; render(); saveState(); }
}

/* ---------- 既読スキップ（次の未読 or 分岐まで） ---------- */
function skipToNextUnread(){
  let guard=0;
  while(guard++<200){
    const sc = SCENES[state.sceneId];
    if(!sc) break;

    const seen = !!state.seen[state.sceneId];
    const valid = getValidChoices(sc);

    // 未読、または選択肢が複数ある（分岐点）なら停止
    if(!seen || valid.length !== 1){
      render(); // 再描画だけ
      return;
    }
    // 単一選択で既読 → 自動で踏む
    choose(valid[0]);
  }
}

/* ---------- 自動送り ---------- */
function toggleAutoplay(){
  state.flags.autoplay = !state.flags.autoplay;
  if(state.flags.autoplay){ startAutoplay(); } else { stopAutoplay(); }
  renderToggles(); saveState();
}
function startAutoplay(){
  stopAutoplay();
  scheduleAutoplayStep();
}
function stopAutoplay(){
  if(autoplayTimer){ clearTimeout(autoplayTimer); autoplayTimer=null; }
}
function restartAutoplay(){
  if(state.flags.autoplay){ startAutoplay(); }
}
function scheduleAutoplayStep(){
  stopAutoplay();
  autoplayTimer = setTimeout(autoplayStep, state.flags.autoplayMs||1800);
}
function autoplayStep(){
  const sc = SCENES[state.sceneId];
  if(!sc){ return; }
  const valid = getValidChoices(sc);
  if(valid.length === 1){
    choose(valid[0]);
  }else{
    stopAutoplay(); // 分岐では停止
    renderToggles();
  }
}

/* ---------- UI/状態 ---------- */
// REPLACE: updateBadges
function updateBadges(){
  // 何も表示しない。代わりに軌跡ポップアップの内容を最新化
  if(journalModal.style.display === "block"){ renderJournal(); }
}

function renderToggles(){
  document.getElementById("btnToggleSkip").textContent = `既読SKIP: ${state.flags.skipReadToggle ? "ON" : "OFF"}`;
  document.getElementById("btnToggleSkip").classList.toggle("toggle-on", !!state.flags.skipReadToggle);
  document.getElementById("btnAutoplay").textContent = `自動送り: ${state.flags.autoplay ? "ON" : "OFF"}`;
  document.getElementById("btnAutoplay").classList.toggle("toggle-on", !!state.flags.autoplay);
  document.getElementById("speed").value = String(state.flags.autoplayMs||1800);
  document.getElementById("speedVal").textContent = ((state.flags.autoplayMs||1800)/1000).toFixed(1)+"s";
}

// すべてのEDを一覧化（flag は達成判定・scene はリプレイ開始シーンID）
const ED_CATALOG = [
  // 九条（例：あなたのK6aをリプレイ開始に）
  { flag:"ED_Kujou_Love",    label:"【恋愛ED：赦し】",              scene:"K6a" },
  { flag:"ED_Kujou_Truth",    label:"【真実ED：終止報告】",              scene:"K6b" },
  { flag:"ED_Kujou_Collapse",    label:"【崩壊ED：共鳴】",              scene:"K6c" },

  // 朝倉
  { flag:"ED_Asakura_Love",  label:"【恋愛ED：守るための嘘】",      scene:"A6a" },
  { flag:"ED_Asakura_Friend",label:"【友情ED：素顔の交換】",          scene:"A6b" },

  // 湊
  { flag:"ED_Minato_Love",   label:"【恋愛ED：湯気の朝】",                     scene:"M6a" },
  { flag:"ED_Minato_Save",   label:"【救済ED：救いの手】",                     scene:"M6b" },

  // 藤堂
  { flag:"ED_Todo_Love",     label:"【恋愛ED：同速の約束】",                     scene:"R6b" },
  { flag:"ED_Todo_Collapse", label:"【崩壊ED（メリーバッド）：白い飽和】",     scene:"R6a" },

  // 奏
  { flag:"ED_Kanade_Friend",  label:"【犠牲ED：送り出す朝】",               scene:"N6a" },
  { flag:"ED_Kanade_Friend2", label:"【友情ED：伴走の規約】",                    scene:"N6b" },

  // 隠し
  { flag:"ED_Hidden_True",   label:"【トゥルーED：縫合の完了】",      scene:"H6a" },
  { flag:"ED_Hidden_Bitter", label:"【ビターグッド：継ぎ目の静けさ】",                scene:"H6b" },
];
  
// ADD: 軌跡（ジャーナル）描画
function renderJournal(){
  // 隠し開放
  const hidden = isHiddenUnlocked(state);
  document.getElementById("jrHidden").textContent = hidden ? "解放済" : "未解放";

  // ED数
  const edKeys = Object.keys(state.flags).filter(k=>k.startsWith("ED_"));
  document.getElementById("jrEDCount").textContent = `${edKeys.length} 件`;

  // 欠片
  const frUl = document.getElementById("jrFragments");
  frUl.innerHTML = "";
  if((state.fragments||[]).length===0){
    const li = document.createElement("li"); li.textContent = "未入手";
    frUl.appendChild(li);
  }else{
    state.fragments.forEach(f=>{
      const li = document.createElement("li"); li.textContent = f; frUl.appendChild(li);
    });
  }

  // 好感度
  const afTbl = document.getElementById("jrAffection");
  afTbl.innerHTML = "";
  const entries = Object.entries(state.affection||{});
  if(entries.length===0){
    const tr = document.createElement("tr"); tr.innerHTML = "<td>データなし</td><td></td>"; afTbl.appendChild(tr);
  }else{
    entries.forEach(([name,val])=>{
      const tr = document.createElement("tr");
      tr.innerHTML = `<td>${name}</td><td style="text-align:right">${val}</td>`;
      afTbl.appendChild(tr);
    });
  }

  // ログ
  const logsUl = document.getElementById("jrLogs");
  logsUl.innerHTML = "";
  if((state.logs||[]).length===0){
    const li = document.createElement("li"); li.textContent = "ログはまだありません";
    logsUl.appendChild(li);
  }else{
    state.logs.slice(-200).forEach(l=>{
      const li = document.createElement("li"); li.textContent = l; logsUl.appendChild(li);
    });
  }
}

  // --- ED一覧 ---
  const edUl = document.getElementById("jrEDList");
  if (edUl) {
    edUl.innerHTML = "";
    ED_CATALOG.forEach(ed => {
      const li = document.createElement("li");
      const achieved = !!state.flags[ed.flag];

      if (achieved) {
        // 達成済み：クリックでED再生（シーンがあればボタン）
        const btn = document.createElement("button");
        btn.textContent = ed.label;
        btn.className = "edlink";
        btn.style.margin = "2px 0";
        btn.style.padding = "6px 10px";
        btn.style.borderRadius = "8px";
        btn.style.border = "1px solid #2f3950";
        btn.style.background = "#263146";
        btn.style.color = "var(--ink)";
        btn.onclick = async () => {
          // 必要なら対応ルートファイルを読み込む
          const ok = await ensureSceneLoaded(ed.scene);
          if (!ok && !SCENES[ed.scene]) {
            alert("このEDシーンが未実装です");
            return;
          }
          journalReplayED(ed.scene);
        };
        li.appendChild(btn);
      } else {
        // 未達：？で表示
        const span = document.createElement("span");
        span.textContent = "？";
        span.style.opacity = ".7";
        span.title = ed.label; // ヒントにラベル（不要なら消してOK）
        li.appendChild(span);
      }
      edUl.appendChild(li);
    });
  }
  
function openJournal(){
  renderJournal();
  journalBackdrop.style.display = "block";
  journalModal.style.display = "block";
}

async function journalReplayED(sceneId){
  // モーダル閉じる
  closeJournal();
  // 戻る用ヒストリに現在を積む
  state.history.push(state.sceneId);
  // 念のためここでもロード保証
  const ok = await ensureSceneLoaded(sceneId);
  if (!ok && !SCENES[sceneId]) {
    alert("このEDシーンが未実装です");
    return;
  }
  // 指定EDシーンへジャンプ（ED本編の「記録してタイトルへ」で戻れる）
  state.sceneId = sceneId;
  render();
}

function closeJournal(){
  journalBackdrop.style.display = "none";
  journalModal.style.display = "none";
}
  
// REPLACE: logPush
function logPush(line){
  const stamp = new Date().toLocaleTimeString()+" "+line;
  state.logs.push(stamp);         // ★ state に蓄積
  // 旧#logは非表示のためDOM追記は不要だが、既存利用の互換で残すなら以下コメントアウト解除
  // const p = document.createElement("div");
  // p.textContent = stamp;
  // document.getElementById("log").appendChild(p);
  // document.getElementById("log").scrollTop = document.getElementById("log").scrollHeight;
}

/* ---------- 永続化 ---------- */
function saveState(){ localStorage.setItem("mem_novel_state", JSON.stringify(state)); }
function loadState(){ try{ return JSON.parse(localStorage.getItem("mem_novel_state")); }catch(e){ return null; } }
</script>
</body>
</html>
